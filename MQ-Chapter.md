## 消息中间件篇

#### RabbitMQ保证消息不丢失

在RabbitMQ中，消息丢失分为三种情况：消息未到达交换机或队列、MQ服务宕机导致消息丢失、Listener接收后处理失败导致丢失。下面一一解决

<img src="http://s5cc1wj96.hd-bkt.clouddn.com/202312141124211.png" alt="image-20231214112437097" style="zoom:50%;" />

###### 生产者确认机制

解决消息未到达交换机或队列问题：消息发送到队列后，会返回一个ACK，否则说明消息失败

但是又有两种情况，一种情况是没有到达交换机，这会返回一个nack publish confirm；还有一种是到达交换机但没有到达队列，会返回ack publish-return。

如果失败，有三种解决方案：

* 记录日志
* 回调失败的方法
* 保存到数据库，开启定时重发任务

###### 消息持久化

解决MQ宕机问题：对消息、队列、交换机都要做持久化

###### 消费者确认机制

MQ存在三种确认机制

* manual：手动确认，处理完需要手动发送ack
* auto：spring检测消费者执行时候是否出现异常，没有则自动ack，否则nack
* none：默认接收到消息就自动ack了

如果消费者无法接收消息，还会提供一个重试机制，到达一定重试次数，就会自动投递到异常交换机，由人工处理



#### RabbitMQ消费重复消费

当消费者正常处理完消息后，还没有来得及发送ACK网络就发生了抖动或者直接宕机，导致没有ACK成功，就会导致消息可能被再次消费

解决方案：

* 发送消息前可以先插入一条业务记录到数据库，如果消费者消费成功，可以改变该记录状态。并且消费者消费之前会先查看该记录的状态，避免重复消费
* 使用幂等性方案，用分布式锁（一般不用）



#### RabbitMQ的死信交换机

###### 死信交换机

消息成为死信的情况：

* 消费者拒绝消费或者消费失败
* 消息在队列中过期
* 队列堆积满了

如果成为死信，且设置了该队列的死信交换机，那么就会被自动投递到死信交换机

###### 基于死信的延迟队列

搞一个交换机和队列，并且该队列设置死信交换机和对应的死信队列，但是不提供消费者，那么一旦发送具有ttl’的消息，超时后就会自动投递至死信交换机

我们只需要消费者监听死信队列的消息就可以实现延迟处理了

设置ttl有两种方式，一个是发送的时候给消息设置ttl，还一个是声明队列的时候设置ttl，这两个ttl取短的那个为最终延迟的时间



#### RabbitMQ的消息堆积

当生产者发送消息的速度大于消费者处理的速度时，就会导致消息堆积，当达到队列存储上限的时候，后续的消息就会成为死信

三种解决方案：

* 增加更多的消费者
* 在消费者内部开启线程池
* 扩大队列容量

其中扩大队列容量不是直接扩大内存，而是使用惰性队列，将消息存储到磁盘中，需要的时候再读取



#### RabbitMQ的集群

###### 普通集群

在集群中共享部分数据：交换机、所有队列的位置

当集群访问某节点时，发现需要的队列不在该节点上，那么会根据队列位置路由到对应节点返回

<img src="http://s5cc1wj96.hd-bkt.clouddn.com/202312141608131.png" alt="image-20231214160808010" style="zoom:50%;" />

但是这种模式可用性不高，一旦有节点宕机，那么该节点上的独队列都无法访问

###### 镜像集群

使用主从模式，交换机、队列、消息都会在每个节点中保存一份

创建队列的节点就是该队列的主节点，而其他节点就是镜像节点（由于主从是针对队列而言的，因此一个队列的主节点可能是另一个队列的镜像节点）

主节点完成该队列的所有操作，主节点宕机过后，镜像节点会替代成为新的主节点

> 若在同步之前主节点宕机了，还是无法实现强一致性。若想实现强一致性，可以使用仲裁队列