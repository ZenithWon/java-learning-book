## MySQL篇

#### 慢查询

**如何定位**

1. 可以使用运维工具，查看调用时间很长的接口，分析原因是否在MySql，如skywalking
2. 使用mysql自带的慢日志，需要在配置文件中配置开启该功能，这样mysql会将查询时间超过指定值的sql语句记录下来。

**如何优化慢查询**

有时候即使给sql添加了的索引，但是执行的还是很慢，一般有以下几种原因：

* 聚合查询（聚合操作计算耗时）
* 多表查询（涉及表连接，耗时）
* 表数据量过大（数据多，查找时间长）
* 深度分页查询

前三种原因都可以通过分析sql执行计划找到慢的原因

在mysql中使用`EXPLAIN [执行语句]`或者`DESC [执行语句]`命令查看执行信息

![image-20231204112327848](https://raw.githubusercontent.com/ZenithWon/figure/master/image-20231204112327848.png)

我们一般关注以下几个字段的信息：

* possible_key：sq语句可能会使用到的索引
* key：实际命中的索引
* key_len：用到的索引占用的大小
* extra：额外的优化建议
* type：sql的连接类型，性能从好到坏顺序为 NULL，system，const，eq_ref，ref，range，index，all

根据这些字段，可以分析：

* 根据key和key_len检查是否使用了索引查询
* 根据type字段检查连接类型性能是否可以优化
* 根据extra字段检查查询是否回表



#### 索引

**定义**

帮助mysql高效获取数据的数据结构（有序的）

**底层数据结构（B+树）**

<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/image-20231204165220861.png" alt="image-20231204165220861" style="zoom:33%;" />

* 和B树不同的是，B+树的非叶子节点不存储信息，value存在每个叶子节点里面。也就是说，数据库中的每条记录都对应一个叶子节点

**索引创建的原则**

* 数据量较大，并且查询频繁，可以为该表创建索引
* 对于需要创建索引的表，可以给经常用于order by、where、group by的字段添加索引
* 尽量使用区分度较高的字段作为索引，比如唯一索引
* 如果是字符串字段，可以根据字符串的特点建立前缀索引
* 尽量使用联合索引而不是单列索引，这样可以使用覆盖索引，减少回表查询几率
* 索引数量不是越多越好，过多的索引会增加存储空间，而且影响增删改效率

**索引失效**

1. 当使用联合索引的时候，没有遵循最左查询原则，索引会失效（即需要根据联合索引的顺序，从左到右不能跳过）
2. 范围查询条件右边条件，使用到的列无法使用索引
3. 索引列上做运算操作，也会导致失效（隐式类型转换也会导致，比如查询字符的时候没有加引号）
4. 模糊匹配的时候，如果头部有百分号，就会失效，如`select * from tb_demo like '%test'`



#### 聚簇索引和非聚簇索引

**概念**

* 聚簇索引（聚集索引）：将数据存储和索引放到一起，并且叶子节点保存整条记录数据。这个每张表都会有且只有一个，在创建表的时候就会生成，生成规律如下：
  * 有主键，那么主键索引就是聚簇索引
  * 没有主键，但又unique字段，使用第一个unique字段构建聚簇索引
  * 啥都没有，那么会自动生成一个rowid作为聚簇索引
* 非聚簇索引（二级索引）：将数据和索引分开存储，其叶子节点只关联记录对应的主键。可以有零个或多个，这个需要人为创建

**回表查询**

如果查询涉及的索引是二级索引，由于二级索引存储的是主键，因此还会回到聚集索引中根据主键查询整条记录，这就发生了回表查询。

<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/image-20231204173749766.png" alt="image-20231204173749766" style="zoom:33%;" />



#### 覆盖索引

**定义**
查询时候使用了索引，并且需要返回的列中可以从这个索引的数据中全部找到，即不需要回表查询了

**超大分页处理**

由于在mysql中使用分页查询的时候即使order字段创建了索引，也会走全表查询，因此会导致回表，如果limit的时候靠后的数据，会大大消耗时间。

解决方案：先select 覆盖索引的部分，然后通过主键连接找出所有数据，这样就可以使用上索引了。

```mysql
select * from tb_item t1 join (select name from tb_item order by name limit 1000000,10) t2 on t1.id=t2.id
```



#### sql优化

* 表设计优化，选择合适的数据类型
* 索引优化，创建索引的原则
* sql语句优化，使用覆盖索引、避免索引失效
* 主从复制，读写分离
* 分库分表



#### 事务

事务时一组操作的集合，要么同时成功，要么同时失败

**事务的特性（ACID）**

**A**tomicy 原子性、**C**onsistency 一致性、**I**solation 隔离性、**D**urability 持久性

**并发事务带来的问题**

脏读：一个事务读到了另一个事务还没有提交的数据，一旦第一个事务回滚，就会出问题

<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/image-20231205105857480.png" alt="image-20231205105857480" style="zoom: 50%;" />

不可重复读：一个事务读了两次数据，但是读到的数据却不一样

<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/image-20231205110112755.png" alt="image-20231205110112755" style="zoom:50%;" />

幻读：一个事务查询的时候没有对应数据行，但是插入的时候却又显示该数据已经存在，插入失败了（“幻影”一样）

> 注意的是再次查询还是查询不到，因为已经解决了不可重复读的问题，即解决了读一致性。虽然数据在事务二已经写入，但还是读不到。而插入的时候由于数据确实存在，因此插入失败

<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/image-20231205110444229.png" alt="image-20231205110444229" style="zoom:50%;" />

**事务隔离**

解决上述并发事务的问题，就是对事务进行隔离。MySQL有四种隔离级别

* Read uncommitted 未提交读：可以读取未提交的数据，无法解决并发事务的任何问题
* Read commited 读已提交：未提交的事务无法读到其数据，可以解决脏读问题
* Repeatable read 可重复读（默认级别）：可以解决不可重复读问题，读一致性
* Serializable（串行化）：事务只能串行运行，可以解决所有问题，但是失去了并发事务的功能



#### ACID数据库的实现

**redo log**

这个保证了数据库的持久性（Durability）。由于在msql中，事务的执行不是直接写到磁盘内的，而是先写到内存然后同步到磁盘。如果同步的时候出现错误，那么就会导致丢失数据，因此mysql使用redo log记录执行过的指令，一旦内存无法同步，就会使用redo log恢复数据

> 为什么使用redo log，为什么不直接将数据同步到磁盘？
>
> 因为日志文件是按顺序的，不用频繁的换页；而事务的执行是随机的，可能会频繁的换页。注意的是，执行日志文件的时候是写磁盘，**不涉及换页**

<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/image-20231205113329676.png" alt="image-20231205113329676" style="zoom: 40%;" />

**undo log**

这个保证了数据库的一致性和原子性（Consistency、Atomicy），用于事务的回滚操作。记录的是执行指令相反的数据，比如事务提交了delete那么这里就会记录一个insert

一旦事务需要回滚，就会执行undo log中的指令



#### MVCC

**多版本并发控制**（Multi-Version Concurrency Control，MVCC）：维护一个数据的多个版本，使得读写没有冲突，保证了数据库的隔离性（Isolation）

**隐藏字段**

* `trx_id` 记录每次操作的事务id
* `roll_pointer`记录上一个版本的事务记录地址，其实就是undo_log中的最新的历史记录地址
* `row_id`隐藏主键，如果没有主键就用这个。在MVCC这里，我们只关注前两个字段

**undo_log**

用于记录修改记录的历史信息，需要连同隐藏字段一同记录，由于`roll_pointer`字段指向的是当前版本在undo_log中对于的最新的历史记录，因此实际上对于同一条记录，多次修改就会产生一个**undo_log链**。

<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/image-20231205160939015.png" alt="image-20231205160939015" style="zoom:50%;" />

**ReadView（读视图）**

在事务中，每次查询都是根据读视图去undo_log中检索数据的，而不是直接使用最新数据，从而实现多版本并发控制。

在生成读视图时，需要记录四个字段，代表版本信息

* `m_id`：活跃的事务id集合，即未提交的事务id
* `min_trx_id`：m_id中最小的id
* `max_trx_id`：m_id中最大的id+1
* ``creator_trx_id`：创建该视图的id

事务想查询数据的时候，会根据读视图，按照undo_log链访问，直至记录的trx_id满足读视图的限制，就会返回数据的对于版本

* trx_id==creator_trx_id   可以访问
* trx_id<min_trx_id  可以访问
* trx_id>max_trx_id  不可访问
* min_trx_id<= trx_ix<=max_trx_id && trx_id NOT IN m_id  可以访问

然而对于不同的隔离等级，创建视图的策略也不一样：

* Read Committed：每次读的时候都会创建读视图
* Repeatable Read：只会在第一个select的时候创建

> 也就是说，RC在每个读之前都会生成一个读视图，因此每次读的时候数据可能不一样。而RR由于会对第一个读视图复用，因此每次读的数据是一样的，实现可重复读



#### mysql的主从同步原理

和redis一样，同样也是读写分离，然后主库给从库同步

<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/image-20231205164948737.png" alt="image-20231205164948737" style="zoom: 33%;" />

主库会使维护binlog日志文件，该文件记录了所有的DDL和DML语句，但不包括select等查询语句

从库会通过IOThread读取binlog文件存储到本地的一个relay log（中继日志）中，然后再通过SqlThread执行relay log中的指令，实现同步



#### mysql分库分表

读写分离分担访问压力，而分库分表分担的是存储压力

**垂直拆分**

* 垂直分库：以表为依据，将不同表拆分到不同库中
* 垂直分表：以字段为依据，将不同字段拆分到不同表中，比如把大文本字段单独存储，或者不常用的字段单独存储

**水平拆分**

* 水平分库：将一个库的数据，拆到多个库中。当查询的时候，可以通过某种路由规则去查询指定库，比如根据id的哈希值取模（类似插槽），或者直接添加一个字段标识所在数据库
* 水平分表：将一个表的数据，拆到多个表中（可以在同一个库中）。也可以通过类似水平分库的路由方式，去所在表查找

**新的问题**

当分库分表后，就会产生分布式的一些新问题

* 分布式事务的一致性，多个数据库，如何同时回滚
* 跨节点的关联查询
* 跨节点的分页查询、排序
* 主键重复问题，如果都是自增的，可能会重复

一般为了降低开发难度，会在客户端和mysql集群之间加上一个中间件，如Mycat