## MySQL篇

#### 慢查询

**如何定位**

1. 可以使用运维工具，查看调用时间很长的接口，分析原因是否在MySql，如skywalking
2. 使用mysql自带的慢日志，需要在配置文件中配置开启该功能，这样mysql会将查询时间超过指定值的sql语句记录下来。

**如何优化慢查询**

有时候即使给sql添加了的索引，但是执行的还是很慢，一般有以下几种原因：

* 聚合查询（聚合操作计算耗时）
* 多表查询（涉及表连接，耗时）
* 表数据量过大（数据多，查找时间长）
* 深度分页查询

前三种原因都可以通过分析sql执行计划找到慢的原因

在mysql中使用`EXPLAIN [执行语句]`或者`DESC [执行语句]`命令查看执行信息

![image-20231204112327848](https://raw.githubusercontent.com/ZenithWon/figure/master/image-20231204112327848.png)

我们一般关注以下几个字段的信息：

* possible_key：sq语句可能会使用到的索引
* key：实际命中的索引
* key_len：用到的索引占用的大小
* extra：额外的优化建议
* type：sql的连接类型，性能从好到坏顺序为 NULL，system，const，eq_ref，ref，range，index，all

根据这些字段，可以分析：

* 根据key和key_len检查是否使用了索引查询
* 根据type字段检查连接类型性能是否可以优化
* 根据extra字段检查查询是否回表



#### 索引

**定义**

帮助mysql高效获取数据的数据结构（有序的）

**底层数据结构（B+树）**

<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/image-20231204165220861.png" alt="image-20231204165220861" style="zoom:33%;" />

* 和B树不同的是，B+树的非叶子节点不存储信息，value存在每个叶子节点里面。也就是说，数据库中的每条记录都对应一个叶子节点



#### 聚簇索引和非聚簇索引

**概念**

* 聚簇索引（聚集索引）：将数据存储和索引放到一起，并且叶子节点保存整条记录数据。这个每张表都会有且只有一个，在创建表的时候就会生成，生成规律如下：
  * 有主键，那么主键索引就是聚簇索引
  * 没有主键，但又unique字段，使用第一个unique字段构建聚簇索引
  * 啥都没有，那么会自动生成一个rowid作为聚簇索引
* 非聚簇索引（二级索引）：将数据和索引分开存储，其叶子节点只关联记录对应的主键。可以有零个或多个，这个需要人为创建

**回表查询**

如果查询涉及的索引是二级索引，由于二级索引存储的是主键，因此还会回到聚集索引中根据主键查询整条记录，这就发生了回表查询。

<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/image-20231204173749766.png" alt="image-20231204173749766" style="zoom:33%;" />



#### 覆盖索引

**定义**
查询时候使用了索引，并且需要返回的列中可以从这个索引的数据中全部找到，即不需要回表查询了

**超大分页处理**

由于在mysql中使用分页查询的时候即使order字段创建了索引，也会走全表查询，因此会导致回表，如果limit的时候靠后的数据，会大大消耗时间。

解决方案：先select 覆盖索引的部分，然后通过主键连接找出所有数据，这样就可以使用上索引了。

```mysql
select * from tb_item t1 join (select name from tb_item order by name limit 1000000,10) t2 on t1.id=t2.id
```

